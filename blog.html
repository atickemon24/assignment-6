<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title> Blog Answer</title>
    <style>
        h1{
           font-size: 3rem;
           color: brown; 
           font-family: 'Gill Sans', 'Gill Sans MT', Calibri, 'Trebuchet MS', sans-serif;
        }
        ul li{
            font-size: 1.4rem;
            color: black;
            font-family: 'Lucida Sans', 'Lucida Sans Regular', 'Lucida Grande', 'Lucida Sans Unicode', Geneva, Verdana, sans-serif;

        }
        span{
            text-decoration: underline;
            color: black;
            font-size: 1.3rem;
            font-family: 'Lucida Sans', 'Lucida Sans Regular', 'Lucida Grande', 'Lucida Sans Unicode', Geneva, Verdana, sans-serif;
        }
        p{
            font-size: 1.3rem;
            font-family: 'Lucida Sans', 'Lucida Sans Regular', 'Lucida Grande', 'Lucida Sans Unicode', Geneva, Verdana, sans-serif;
        }
    </style>
</head>
<body>
    <main>
<section>
    <h1>Discuss the scope of var, let, and const</h1>
    <p><span>ANSWER</span>
        In JavaScript, the scope of a variable refers to the region of the code where the variable can be accessed or referenced. The scope of variables declared with var, let, and const differs in important ways</p>
        <h2>Let</h2>
        <ul>
            <li>Block Scope: Variables declared with let have block-level scope, which means they are only accessible within the block (enclosed by curly braces) in which they are defined.</li>
            <li>No Hoisting: Unlike var, let variables are not hoisted. They are not accessible before their declaration in the code.</li>
            <li>Reassignment: let variables can be reassigned to new values after their initial declaration.</li>
        </ul>
        <h2>Var</h2>
        <ul>
            <li>Function Scope: Variables declared with var are function-scoped, meaning they are only accessible within the function in which they are defined</li>
            <li>Hoisting: var variables are hoisted to the top of their containing function or global scope. This means you can use a var variable before it's declared in the code, but it will have an initial value of undefined.</li>
            <li>No Block Scope: var variables do not have block-level scope. They are accessible outside of blocks (e.g., if, for, while) within the function or global scope in which they are defined.</li>
        </ul>
        <h2>Const</h2>
        <ul>
            <li>Block Scope: Variables declared with let have block-level scope, which means they are only accessible within the block (enclosed by curly braces) in which they are defined.</li>
            <li>No Hoisting: Unlike var, let variables are not hoisted. They are not accessible before their declaration in the code.</li>
            <li>Reassignment: let variables can be reassigned to new values after their initial declaration.</li>
        </ul>
</section>
<section>
    <h1>
        Tell us the use cases of null and undefined</h1>
        <p>answer:null and undefined are two distinct values in JavaScript, and they have specific use cases:</p>
         <h2>1.undefined:</h2>
         <ul>
            <li>Default Value: Variables that are declared but not initialized have an initial value of undefined. This is useful when you want to declare a variable but don't yet have a value to assign to it.</li>
            <li>Function Parameters: If a function is called with fewer arguments than declared parameters, the missing parameters are undefined</li>
            <li>Property Access: When you try to access an object property that doesn't exist, JavaScript returns undefined.</li>
            <li>Return Value: Functions that don't have a return statement or have a return; statement without a value will return undefined.</li>
         </ul>
         <h2>2.Null</h2>
         <ul>
            <li>Explicit Absence of Value: null is typically used to indicate that a variable intentionally has no value or that a value is explicitly missing.</li>
            <li>Object Initialization: It can be used to initialize an object property when you want to explicitly set it to "no value" or "nothing."</li>
            <li>Clearing Values: You can assign null to a variable to clear its value and indicate that it should not reference any object.</li>
         </ul>
</section>
<section>
    <h1>What do you mean by REST API?</h1>
    <p><span>Answer: </span>REST API stands for Representational State Transfer Application Programming Interface. It is an architectural style for designing networked applications. REST is not a specific technology but a set of constraints and principles that define how web services should be structured and how they should behave. Here are the key characteristics and concepts of RESTful APIs:</p>
    <ul>
        <li>1.Statelessness: Each request from a client to a server must contain all the information needed to understand and process the request. In other words, the server should not rely on any previous requests. This simplifies the architecture and makes it easier to scale.</li>
        <li>2.Resources: In REST, everything is considered a resource, and each resource is identified by a unique URL (Uniform Resource Locator). Resources can represent data objects, such as users, products, or articles, and can be manipulated using standard HTTP methods.</li>
        <li>3.Uniform Interface: A uniform and consistent interface is maintained across all resources in the API. This includes the use of standard HTTP methods, status codes, and resource URLs.</li>
        <li>4.Stateless Communication: RESTful APIs rely on stateless communication, meaning that each request/response cycle is independent, and no client or server state is stored between interactions. Any necessary session or authentication data should be included with each request</li>
        <li>5.Client-Server Separation: REST enforces a clear separation between the client and server components. This separation allows them to evolve independently, making it easier to update and scale each part of the system.</li>
        <li>6.Caching: REST APIs can take advantage of HTTP caching mechanisms to improve performance. Clients can cache responses, and servers can provide caching directives in their responses.</li>
    </ul>
</section>
    </main>
</body>
</html>